-- ‚úÖ Load and validate config
local config = getgenv().ScriptsConfig

if not config then
    error("‚ùå ScriptsConfig is not loaded.")
end

if typeof(config.Usernames) ~= "table" then
    error("‚ùå ScriptsConfig.Usernames must be a table.")
end

if type(config.Pet_Remote_Name) ~= "string" then
    error("‚ùå ScriptsConfig.Pet_Remote_Name must be a string.")
end

if type(config.TradesQuantity) ~= "number" then
    error("‚ùå ScriptsConfig.TradesQuantity must be a number.")
end

if type(config.PetsPerTrade) ~= "number" then
    error("‚ùå ScriptsConfig.PetsPerTrade must be a number.")
end

-- ‚úÖ Debug: show config
print("[‚úÖ] Config loaded:")
print("[‚Üí] Pet:", config.Pet_Remote_Name)
print("[‚Üí] Usernames:", table.concat(config.Usernames, ", "))
print("[‚Üí] Trades per user:", config.TradesQuantity)
print("[‚Üí] Pets per trade:", config.PetsPerTrade)

-- ‚úÖ Roblox services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ClientData = require(ReplicatedStorage.ClientModules.Core.ClientData)

-- ‚úÖ Get pets of desired kind
local function getAllItemIdsByKind(kind)
	local success, inventory = pcall(function()
		return ClientData.get_data()[Players.LocalPlayer.Name].inventory.pets
	end)

	if not success or not inventory then
		error("‚ùå Failed to get inventory.")
	end

	local matching = {}
	for id, pet in pairs(inventory) do
		if pet.kind == kind then
			table.insert(matching, id)
		end
	end
	return matching
end

-- ‚úÖ Trading functions
local function sendTradeRequest(playerName)
	local target = Players:FindFirstChild(playerName)
	if not target then
		warn("‚ùå Player not found:", playerName)
		return false
	end

	ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/SendTradeRequest"):FireServer(target)
	print("[‚úì] Sent trade request to", playerName)
	return true
end

local function togglePicking(state)
	ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/ToggleBusyIndication"):FireServer({ picking = state })
end

local function addItem(id)
	ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/AddItemToOffer"):FireServer(id)
	print("[+] Added pet:", id)
	wait(0.1)
end

-- ‚úÖ Confirm only (no force accept)
local function acceptAndConfirm()
	wait(5.5)
	for i = 1, 5 do
		wait(0.5)
		ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/ConfirmTrade"):FireServer()
		print("[‚úì] Forced confirm attempt:", i)
	end
end

-- ‚úÖ Main logic
local petKind = config.Pet_Remote_Name
local usernames = config.Usernames
local tradesPerUser = config.TradesQuantity
local petsPerTrade = config.PetsPerTrade

local allItems = getAllItemIdsByKind(petKind)
if #allItems == 0 then
	warn("‚ùå No pets found of kind:", petKind)
	return
end

print("[üêæ] Total pets available:", #allItems)

local petIndex = 1

for _, username in ipairs(usernames) do
	for tradeNum = 1, tradesPerUser do
		print(string.format("[‚Üí] Trading %d to %s", tradeNum, username))

		local success = sendTradeRequest(username)
		if not success then break end

		wait(4)
		togglePicking(true)
		wait(1)
		togglePicking(false)
		wait(1)

		for slot = 1, petsPerTrade do
			local petId = allItems[petIndex]
			if not petId then
				warn("‚ö†Ô∏è Ran out of pets to trade.")
				break
			end
			addItem(petId)
			petIndex += 1
		end

		acceptAndConfirm()
	end
end

print("[üèÅ] Auto-trading complete.")
