-- ✅ Load and validate config
local config = getgenv().ScriptsConfig

if not config then
    error("❌ ScriptsConfig is not loaded.")
end

if typeof(config.Usernames) ~= "table" then
    error("❌ ScriptsConfig.Usernames must be a table.")
end

if type(config.Pet_Remote_Name) ~= "string" then
    error("❌ ScriptsConfig.Pet_Remote_Name must be a string.")
end

if type(config.TradesQuantity) ~= "number" then
    error("❌ ScriptsConfig.TradesQuantity must be a number.")
end

if type(config.PetsPerTrade) ~= "number" then
    error("❌ ScriptsConfig.PetsPerTrade must be a number.")
end

-- ✅ Debug: show config
print("[✅] Config loaded:")
print("[→] Pet:", config.Pet_Remote_Name)
print("[→] Usernames:", table.concat(config.Usernames, ", "))
print("[→] Trades per user:", config.TradesQuantity)
print("[→] Pets per trade:", config.PetsPerTrade)

-- ✅ Roblox services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ClientData = require(ReplicatedStorage.ClientModules.Core.ClientData)

-- ✅ Get pets of desired kind
local function getAllItemIdsByKind(kind)
	local success, inventory = pcall(function()
		return ClientData.get_data()[Players.LocalPlayer.Name].inventory.pets
	end)

	if not success or not inventory then
		error("❌ Failed to get inventory.")
	end

	local matching = {}
	for id, pet in pairs(inventory) do
		if pet.kind == kind then
			table.insert(matching, id)
		end
	end
	return matching
end

-- ✅ Trading functions
local function sendTradeRequest(playerName)
	local target = Players:FindFirstChild(playerName)
	if not target then
		warn("❌ Player not found:", playerName)
		return false
	end

	ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/SendTradeRequest"):FireServer(target)
	print("[✓] Sent trade request to", playerName)
	return true
end

local function togglePicking(state)
	ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/ToggleBusyIndication"):FireServer({ picking = state })
end

local function addItem(id)
	ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/AddItemToOffer"):FireServer(id)
	print("[+] Added pet:", id)
	wait(0.1)
end

-- ✅ Accept and confirm only when pets are fully added
local function acceptAndConfirm(expectedCount)
	local connection

	connection = ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/ClientTradeUpdated").OnClientEvent:Connect(function(data)
		if data and data.offeredPets and #data.offeredPets >= expectedCount then
			connection:Disconnect()

			-- ✅ Accept after all pets are added
			ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/AcceptNegotiation"):FireServer()
			print("[✓] Trade accepted")

			wait(0.5)
			for i = 1, 5 do
				wait(0.5)
				ReplicatedStorage:WaitForChild("API"):WaitForChild("TradeAPI/ConfirmTrade"):FireServer()
				print("[✓] Forced confirm attempt:", i)
			end
		end
	end)
end

-- ✅ Main logic
local petKind = config.Pet_Remote_Name
local usernames = config.Usernames
local tradesPerUser = config.TradesQuantity
local petsPerTrade = config.PetsPerTrade

local allItems = getAllItemIdsByKind(petKind)
if #allItems == 0 then
	warn("❌ No pets found of kind:", petKind)
	return
end

print("[🐾] Total pets available:", #allItems)

local petIndex = 1

for _, username in ipairs(usernames) do
	for tradeNum = 1, tradesPerUser do
		print(string.format("[→] Trading %d to %s", tradeNum, username))

		local success = sendTradeRequest(username)
		if not success then break end

		wait(4)
		togglePicking(true)
		wait(1)
		togglePicking(false)
		wait(1)

		for slot = 1, petsPerTrade do
			local petId = allItems[petIndex]
			if not petId then
				warn("⚠️ Ran out of pets to trade.")
				break
			end
			addItem(petId)
			petIndex += 1
		end

		-- ✅ Only accept/confirm after all pets are added
		acceptAndConfirm(petsPerTrade)
	end
end

print("[🏁] Auto-trading complete.")
